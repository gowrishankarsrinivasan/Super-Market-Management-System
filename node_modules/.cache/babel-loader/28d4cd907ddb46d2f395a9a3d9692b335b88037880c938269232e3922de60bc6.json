{"ast":null,"code":"function isBindingValueValid(bindingValue) {\n  if (bindingValue) {\n    if (bindingValue.threshold !== undefined) {\n      if (bindingValue.callback && typeof bindingValue.callback === 'function') {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction getRelativeScrollPositionToElement(el, elementOffset) {\n  const currentScroll = el._scrollElement.scrollY || el._scrollElement.pageYOffset || el._scrollElement.scrollTop || 0;\n  const elementScroll = (el.offsetTop || 0) + (elementOffset || 0);\n  if (currentScroll === 0 && elementScroll === 0) {\n    /**\n     * since we can't go past the element at the top,\n     * we have to have a way of telling that we have went reached the top but\n     * still inside the element and\n     * maybe the user need to trigger sth\n     */\n    return -0;\n  }\n  return currentScroll - elementScroll;\n}\nfunction isMinusZero(value) {\n  if (Object.is(value, -0)) return true;\n}\nfunction scrollPosition(el, elementOffset) {\n  const scrollRelativePos = getRelativeScrollPositionToElement(el, elementOffset);\n  if (scrollRelativePos < 0) {\n    return -1;\n  } else if (scrollRelativePos === 0) {\n    // this is for letting -0 through\n    return scrollRelativePos;\n  } else if (scrollRelativePos >= 0 && scrollRelativePos <= el._scrollThreshold) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nfunction isAlongDirection(modifiers, offset) {\n  let direction = 'down';\n  if (offset > 0) {\n    direction = 'up';\n  }\n  if (modifiers[direction]) {\n    return true;\n  }\n  return false;\n}\nconst evtOpts = {\n  passive: true\n};\nconst bind = (el, binding) => {\n  if (!isBindingValueValid(binding.value)) {\n    return;\n  }\n  el._thresholdCallback = binding.value.callback || (() => {});\n  el._scrollThreshold = binding.value.threshold || 0;\n  el._detectionOffset = binding.value.offset || 0;\n  el._scrollBackThreshold = binding.value.scrollBackThreshold || 0;\n  el._scrollBackValue = 0;\n  el._scrollElement = binding.value.scrollElement || window;\n  let startingRelativeScrollPos = scrollPosition(el, el._detectionOffset);\n  let lastScrollPos = el._scrollElement.scrollY || el._scrollElement.pageYOffset || el._scrollElement.scrollTop || 0;\n  let lastWasAlong = false;\n  const scrollHandler = function scrollHandler() {\n    const newRelativeScrollPos = scrollPosition(el, el._detectionOffset);\n    const newScrollPos = el._scrollElement.scrollY || el._scrollElement.pageYOffset || el._scrollElement.scrollTop || 0;\n    const offset = lastScrollPos - newScrollPos;\n    lastScrollPos = newScrollPos;\n    const newIsAlong = isAlongDirection(binding.modifiers, offset);\n    if (newIsAlong) {\n      el._scrollBackValue += Math.abs(offset);\n    } else {\n      el._scrollBackValue = 0;\n    }\n    const isMinusZ = isMinusZero(newRelativeScrollPos);\n    if (el._scrollBackThreshold && newIsAlong && !isMinusZ && el._scrollBackValue < el._scrollBackThreshold && newRelativeScrollPos !== 0) {\n      return;\n    }\n    if (isMinusZ || newRelativeScrollPos !== startingRelativeScrollPos || lastWasAlong !== newIsAlong) {\n      startingRelativeScrollPos = newRelativeScrollPos;\n      lastWasAlong = newIsAlong;\n      el._thresholdCallback(newRelativeScrollPos, newIsAlong);\n    }\n  };\n  el._scrollElement.addEventListener('scroll', scrollHandler, evtOpts);\n  scrollHandler();\n  el._scrollHandler = scrollHandler;\n};\nconst unbind = el => {\n  if (!el._scrollHandler) return;\n  el._scrollElement && el._scrollElement.removeEventListener('scroll', el._scrollHandler, evtOpts);\n  delete el._scrollHandler;\n  delete el._thresholdCallback;\n  delete el._scrollThreshold;\n  delete el._scrollBackThreshold;\n  delete el._detectionOffset;\n  delete el._scrollElement;\n};\nconst update = (el, binding) => {\n  if (typeof binding.value.scrollElement !== 'undefined' && el._scrollElement !== binding.value.scrollElement) {\n    unbind(el);\n    bind(el, binding);\n  } else {\n    el._thresholdCallback = binding.value.callback || (() => {});\n    el._scrollThreshold = binding.value.threshold || 0;\n    el._scrollBackThreshold = binding.value.scrollBackThreshold || 0;\n    el._detectionOffset = binding.value.offset || 0;\n  }\n};\nvar directive = {\n  bind,\n  beforeMount: bind,\n  // vue 3\n  unbind,\n  unmounted: unbind,\n  // vue 3\n  update,\n  updated: update // vue 3\n};\nconst install = function installVScrollThreshold(Vue) {\n  if (install.installed) return;\n  install.installed = true;\n  Vue.directive('ScrollThreshold', directive);\n};\nconst plugin = {\n  install\n};\n\n// To auto-install when vue is found\n// eslint-disable-next-line no-redeclare\n/* global window, global */\nlet GlobalVue = null;\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\nif (GlobalVue && GlobalVue.use) {\n  GlobalVue.use(plugin);\n}\ndirective.install = install;\nexport default directive;","map":{"version":3,"names":["isBindingValueValid","bindingValue","threshold","undefined","callback","getRelativeScrollPositionToElement","el","elementOffset","currentScroll","_scrollElement","scrollY","pageYOffset","scrollTop","elementScroll","offsetTop","isMinusZero","value","Object","is","scrollPosition","scrollRelativePos","_scrollThreshold","isAlongDirection","modifiers","offset","direction","evtOpts","passive","bind","binding","_thresholdCallback","_detectionOffset","_scrollBackThreshold","scrollBackThreshold","_scrollBackValue","scrollElement","window","startingRelativeScrollPos","lastScrollPos","lastWasAlong","scrollHandler","newRelativeScrollPos","newScrollPos","newIsAlong","Math","abs","isMinusZ","addEventListener","_scrollHandler","unbind","removeEventListener","update","directive","beforeMount","unmounted","updated","install","installVScrollThreshold","Vue","installed","plugin","GlobalVue","global","use"],"sources":["D:/E-commerce/FrontEnd/my-vue3-project/node_modules/v-scroll-threshold/dist/v-scroll-threshold.esm.js"],"sourcesContent":["function isBindingValueValid(bindingValue) {\n  if (bindingValue) {\n    if (bindingValue.threshold !== undefined) {\n      if (bindingValue.callback && typeof bindingValue.callback === 'function') {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction getRelativeScrollPositionToElement(el, elementOffset) {\n  const currentScroll = el._scrollElement.scrollY || el._scrollElement.pageYOffset || el._scrollElement.scrollTop || 0;\n  const elementScroll = (el.offsetTop || 0) + (elementOffset || 0);\n  if (currentScroll === 0 && elementScroll === 0) {\n    /**\n     * since we can't go past the element at the top,\n     * we have to have a way of telling that we have went reached the top but\n     * still inside the element and\n     * maybe the user need to trigger sth\n     */\n    return -0;\n  }\n  return currentScroll - elementScroll;\n}\nfunction isMinusZero(value) {\n  if (Object.is(value, -0)) return true;\n}\nfunction scrollPosition(el, elementOffset) {\n  const scrollRelativePos = getRelativeScrollPositionToElement(el, elementOffset);\n  if (scrollRelativePos < 0) {\n    return -1;\n  } else if (scrollRelativePos === 0) {\n    // this is for letting -0 through\n    return scrollRelativePos;\n  } else if (scrollRelativePos >= 0 && scrollRelativePos <= el._scrollThreshold) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nfunction isAlongDirection(modifiers, offset) {\n  let direction = 'down';\n  if (offset > 0) {\n    direction = 'up';\n  }\n  if (modifiers[direction]) {\n    return true;\n  }\n  return false;\n}\nconst evtOpts = {\n  passive: true\n};\nconst bind = (el, binding) => {\n  if (!isBindingValueValid(binding.value)) {\n    return;\n  }\n  el._thresholdCallback = binding.value.callback || (() => {});\n  el._scrollThreshold = binding.value.threshold || 0;\n  el._detectionOffset = binding.value.offset || 0;\n  el._scrollBackThreshold = binding.value.scrollBackThreshold || 0;\n  el._scrollBackValue = 0;\n  el._scrollElement = binding.value.scrollElement || window;\n  let startingRelativeScrollPos = scrollPosition(el, el._detectionOffset);\n  let lastScrollPos = el._scrollElement.scrollY || el._scrollElement.pageYOffset || el._scrollElement.scrollTop || 0;\n  let lastWasAlong = false;\n  const scrollHandler = function scrollHandler() {\n    const newRelativeScrollPos = scrollPosition(el, el._detectionOffset);\n    const newScrollPos = el._scrollElement.scrollY || el._scrollElement.pageYOffset || el._scrollElement.scrollTop || 0;\n    const offset = lastScrollPos - newScrollPos;\n    lastScrollPos = newScrollPos;\n    const newIsAlong = isAlongDirection(binding.modifiers, offset);\n    if (newIsAlong) {\n      el._scrollBackValue += Math.abs(offset);\n    } else {\n      el._scrollBackValue = 0;\n    }\n    const isMinusZ = isMinusZero(newRelativeScrollPos);\n    if (el._scrollBackThreshold && newIsAlong && !isMinusZ && el._scrollBackValue < el._scrollBackThreshold && newRelativeScrollPos !== 0) {\n      return;\n    }\n    if (isMinusZ || newRelativeScrollPos !== startingRelativeScrollPos || lastWasAlong !== newIsAlong) {\n      startingRelativeScrollPos = newRelativeScrollPos;\n      lastWasAlong = newIsAlong;\n      el._thresholdCallback(newRelativeScrollPos, newIsAlong);\n    }\n  };\n  el._scrollElement.addEventListener('scroll', scrollHandler, evtOpts);\n  scrollHandler();\n  el._scrollHandler = scrollHandler;\n};\nconst unbind = el => {\n  if (!el._scrollHandler) return;\n  el._scrollElement && el._scrollElement.removeEventListener('scroll', el._scrollHandler, evtOpts);\n  delete el._scrollHandler;\n  delete el._thresholdCallback;\n  delete el._scrollThreshold;\n  delete el._scrollBackThreshold;\n  delete el._detectionOffset;\n  delete el._scrollElement;\n};\nconst update = (el, binding) => {\n  if (typeof binding.value.scrollElement !== 'undefined' && el._scrollElement !== binding.value.scrollElement) {\n    unbind(el);\n    bind(el, binding);\n  } else {\n    el._thresholdCallback = binding.value.callback || (() => {});\n    el._scrollThreshold = binding.value.threshold || 0;\n    el._scrollBackThreshold = binding.value.scrollBackThreshold || 0;\n    el._detectionOffset = binding.value.offset || 0;\n  }\n};\nvar directive = {\n  bind,\n  beforeMount: bind,\n  // vue 3\n  unbind,\n  unmounted: unbind,\n  // vue 3\n  update,\n  updated: update // vue 3\n};\n\nconst install = function installVScrollThreshold(Vue) {\n  if (install.installed) return;\n  install.installed = true;\n  Vue.directive('ScrollThreshold', directive);\n};\nconst plugin = {\n  install\n};\n\n// To auto-install when vue is found\n// eslint-disable-next-line no-redeclare\n/* global window, global */\nlet GlobalVue = null;\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\nif (GlobalVue && GlobalVue.use) {\n  GlobalVue.use(plugin);\n}\ndirective.install = install;\n\nexport default directive;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}